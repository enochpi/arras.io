<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Arras.io - Milestone Progression</title>
  
  <style>
    /* Reset and base styles */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden;
      background: #1a1a2e;
      color: white;
      user-select: none;
    }

    /* Game container */
    #game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    /* Main game canvas */
    #gameCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      cursor: crosshair;
      background: #0f0f1e;
    }

    /* Minimap canvas */
    #minimapCanvas {
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 176px;
      height: 176px;
      border: 2px solid rgba(0, 178, 225, 0.5);
      border-radius: 10px;
      background: rgba(0, 0, 0, 0.8);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    }

    /* Game UI overlay */
    #game-ui {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }

    /* Score and stats display */
    #stats {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px 20px;
      border-radius: 10px;
      border: 2px solid rgba(0, 178, 225, 0.3);
      pointer-events: auto;
    }

    #score, #level {
      font-size: 18px;
      font-weight: bold;
      color: #00B2E1;
      margin-bottom: 5px;
    }

    #milestone-info {
      font-size: 14px;
      color: #FFD700;
      margin-bottom: 10px;
    }

    /* Health and XP bars */
    .bar-container {
      margin-top: 10px;
      width: 200px;
    }

    .bar {
      height: 20px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 10px;
      margin-bottom: 8px;
      position: relative;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .bar-fill {
      height: 100%;
      transition: width 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #health-fill {
      background: linear-gradient(90deg, #4CAF50, #8BC34A);
    }

    #xp-fill {
      background: linear-gradient(90deg, #9C27B0, #E91E63);
    }

    .bar-text {
      font-size: 11px;
      font-weight: bold;
      color: white;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
      position: absolute;
      width: 100%;
      text-align: center;
      line-height: 20px;
    }

    /* Player stats display */
    #player-stats {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border-radius: 10px;
      border: 2px solid rgba(255, 215, 0, 0.3);
      font-size: 12px;
      color: #FFD700;
      pointer-events: auto;
    }

    #player-stats h4 {
      color: #FFD700;
      margin-bottom: 10px;
      text-align: center;
    }

    #player-stats div {
      margin: 4px 0;
      display: flex;
      justify-content: space-between;
    }

    /* Controls info */
    #controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border-radius: 10px;
      border: 2px solid rgba(0, 178, 225, 0.3);
      font-size: 12px;
      pointer-events: auto;
    }

    #controls h4 {
      color: #00B2E1;
      margin-bottom: 10px;
      font-size: 14px;
    }

    #controls div {
      margin: 5px 0;
      color: rgba(255, 255, 255, 0.9);
    }

    #controls strong {
      color: #FFD700;
      margin-right: 5px;
    }

    /* FPS counter */
    #fps {
      position: absolute;
      bottom: 210px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 5px 10px;
      border-radius: 5px;
      font-family: monospace;
      font-size: 12px;
      color: #00FF00;
    }

    /* Minimap label */
    #minimap-label {
      position: absolute;
      bottom: 200px;
      right: 20px;
      color: rgba(255, 255, 255, 0.7);
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    /* Upgrade menu */
    #upgrade-menu {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.95);
      border: 3px solid #00B2E1;
      border-radius: 15px;
      padding: 30px;
      display: none;
      z-index: 100;
      min-width: 400px;
      pointer-events: auto;
      box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8);
    }

    #upgrade-menu:not(.hidden) {
      display: block !important;
    }
    
    #upgrade-menu.hidden {
      display: none !important;
    }

    #upgrade-menu h2 {
      color: #FFD700;
      text-align: center;
      margin-bottom: 20px;
      font-size: 24px;
    }

    #upgrade-options {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 15px;
    }

    .upgrade-option {
      background: rgba(0, 178, 225, 0.2);
      border: 2px solid rgba(0, 178, 225, 0.5);
      border-radius: 10px;
      padding: 15px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .upgrade-option:hover {
      background: rgba(0, 178, 225, 0.4);
      transform: scale(1.05);
    }

    .upgrade-option h4 {
      color: #00B2E1;
      margin-bottom: 5px;
    }

    .upgrade-option p {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.8);
    }

    .close-button {
      background: #FF4444 !important;
      border: none !important;
      color: white !important;
      padding: 8px 12px !important;
      border-radius: 5px !important;
      cursor: pointer !important;
      font-size: 14px !important;
      font-weight: bold !important;
      transition: background 0.3s ease !important;
    }

    .close-button:hover {
      background: #FF6666 !important;
    }

    .menu-instructions {
      text-align: center;
      margin-top: 15px;
      color: #AAA;
      font-size: 12px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      padding-top: 15px;
    }

    /* Milestone notification */
    .milestone-notification {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.95), rgba(255, 140, 0, 0.95));
      border: 3px solid #FFD700;
      border-radius: 15px;
      padding: 20px 30px;
      font-size: 20px;
      font-weight: bold;
      color: #000;
      z-index: 200;
      pointer-events: none;
      animation: milestoneNotify 3s ease-out forwards;
    }

    @keyframes milestoneNotify {
      0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.5);
      }
      20% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.1);
      }
      80% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(1);
      }
    }

    /* Level up notification */
    .level-notification {
      position: fixed;
      top: 30%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, rgba(0, 255, 0, 0.9), rgba(0, 200, 0, 0.9));
      border: 3px solid #00FF00;
      border-radius: 15px;
      padding: 15px 25px;
      font-size: 18px;
      font-weight: bold;
      color: #000;
      z-index: 200;
      pointer-events: none;
      animation: levelNotify 2s ease-out forwards;
    }

    @keyframes levelNotify {
      0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.8);
      }
      30% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.1);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(1);
      }
    }
  </style>
</head>
<body>
  <div id="game-container">
    <!-- Main game canvas -->
    <canvas id="gameCanvas"></canvas>
    
    <!-- Minimap canvas -->
    <canvas id="minimapCanvas"></canvas>
    
    <!-- Game UI overlay -->
    <div id="game-ui">
      <!-- Stats display -->
      <div id="stats">
        <div id="score">Score: 0</div>
        <div id="level">Level: 1</div>
        <div id="milestone-info">Next Milestone: 1000</div>
        <div class="bar-container">
          <div class="bar">
            <div id="health-fill" class="bar-fill" style="width: 100%"></div>
            <div id="health-text" class="bar-text">100/100</div>
          </div>
          <div class="bar">
            <div id="xp-fill" class="bar-fill" style="width: 0%"></div>
            <div id="xp-text" class="bar-text">0/100</div>
          </div>
        </div>
      </div>

      <!-- Player stats -->
      <div id="player-stats">
        <h4>🎯 Player Stats</h4>
        <div>Vision: <span id="vision-stat">100%</span></div>
        <div>Size: <span id="size-stat">100%</span></div>
        <div>Speed: <span id="speed-stat">100%</span></div>
        <div>Health: <span id="health-stat">100%</span></div>
        <div>Bullet Size: <span id="bullet-stat">100%</span></div>
        <div>Milestones: <span id="milestone-count">0</span></div>
      </div>
      
      <!-- Controls info -->
      <div id="controls">
        <h4>Controls</h4>
        <div><strong>WASD/Arrows:</strong> Move</div>
        <div><strong>Mouse:</strong> Aim</div>
        <div><strong>Click/Hold:</strong> Shoot</div>
        <div><strong>U:</strong> Upgrades Menu</div>
        <div><strong>ESC:</strong> Close Menu</div>
        <div style="margin-top: 10px; color: #FFD700;">
          <strong>Milestone System!</strong><br>
          Grow stronger every 1000 points!<br>
          Level up for upgrade points!
        </div>
      </div>

      <!-- FPS counter -->
      <div id="fps">FPS: 0</div>
      
      <!-- Minimap label -->
      <div id="minimap-label">RADAR</div>
      
      <!-- Upgrade menu -->
      <div id="upgrade-menu" class="hidden">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
          <h2 style="margin: 0; color: #FFD700;">🎯 Choose Upgrade</h2>
          <button class="close-button" onclick="window.game?.toggleUpgradeMenu?.()">✕ Close</button>
        </div>
        
        <div id="upgrade-options">
          <div class="upgrade-option" data-upgrade="health">
            <h4>💚 Max Health</h4>
            <p>+20 HP capacity</p>
          </div>
          <div class="upgrade-option" data-upgrade="damage">
            <h4>💥 Damage</h4>
            <p>+25% bullet damage</p>
          </div>
          <div class="upgrade-option" data-upgrade="reload">
            <h4>⚡ Reload Speed</h4>
            <p>+20% fire rate</p>
          </div>
          <div class="upgrade-option" data-upgrade="speed">
            <h4>🏃 Movement Speed</h4>
            <p>+15% tank speed</p>
          </div>
          <div class="upgrade-option" data-upgrade="regen">
            <h4>🩹 Regeneration</h4>
            <p>+50% health regen</p>
          </div>
          <div class="upgrade-option" data-upgrade="bulletSpeed">
            <h4>🚀 Bullet Speed</h4>
            <p>+20% projectile velocity</p>
          </div>
        </div>
        
        <div class="menu-instructions">
          Press <strong>U</strong> or <strong>ESC</strong> to close • Click an upgrade to apply
        </div>
      </div>
    </div>
  </div>
  
  <script>
    // ==================== GAME CONFIGURATION ====================
    const CONFIG = {
      WORLD_WIDTH: 10000,
      WORLD_HEIGHT: 10000,
      GRID_SIZE: 50,
      PLAYER_BASE_SIZE: 30,
      PLAYER_BASE_SPEED: 5,
      PLAYER_BASE_HEALTH: 100,
      PLAYER_REGEN_RATE: 0.1,
      BULLET_BASE_SIZE: 12,
      BULLET_BASE_SPEED: 10,
      BULLET_DAMAGE: 20,
      FIRE_RATE: 200,
      BULLET_LIFETIME: 7000,
      MAX_SHAPES: 200,
      SHAPE_SPAWN_RATE: 10,
      MILESTONE_INTERVAL: 1000, // Every 1000 points
      // Vision and stat multipliers per milestone
      MILESTONE_VISION_BONUS: 0.15,   // +15% vision per milestone
      MILESTONE_SIZE_BONUS: 0.08,     // +8% size per milestone
      MILESTONE_HEALTH_BONUS: 0.12,   // +12% health per milestone
      MILESTONE_SPEED_PENALTY: 0.05,  // -5% speed per milestone
      MILESTONE_BULLET_BONUS: 0.06    // +6% bullet size per milestone
    };

    // ==================== GAME STATE ====================
    class GameState {
      constructor() {
        this.player = {
          id: 'player_' + Math.random().toString(36).substr(2, 9),
          x: CONFIG.WORLD_WIDTH / 2,
          y: CONFIG.WORLD_HEIGHT / 2,
          vx: 0, vy: 0, angle: 0,
          health: CONFIG.PLAYER_BASE_HEALTH,
          maxHealth: CONFIG.PLAYER_BASE_HEALTH,
          score: 0, level: 1, xp: 0, xpToNext: 100,
          upgradePoints: 0,
          milestones: 0,
          lastMilestone: 0,
          // Current stats based on milestones
          currentSize: CONFIG.PLAYER_BASE_SIZE,
          currentSpeed: CONFIG.PLAYER_BASE_SPEED,
          currentMaxHealth: CONFIG.PLAYER_BASE_HEALTH,
          currentBulletSize: CONFIG.BULLET_BASE_SIZE,
          visionRange: 800, // Base vision range
          // Upgrade stats
          stats: { 
            damage: 1, 
            reload: 1, 
            speed: 1, 
            regen: 1, 
            bulletSpeed: 1 
          }
        };
        
        this.projectiles = [];
        this.shapes = [];
        this.particles = [];
        this.camera = { x: 0, y: 0 };
        this.keys = {};
        this.mouse = { x: 0, y: 0, pressed: false };
        this.lastShot = 0;
        this.upgradeMenuOpen = false;
        this.shapeSystem = null;
        this.collisionSystem = null;
      }
      
      reset() {
        this.player.health = this.player.currentMaxHealth;
        this.player.x = CONFIG.WORLD_WIDTH / 2;
        this.player.y = CONFIG.WORLD_HEIGHT / 2;
        this.player.vx = this.player.vy = 0;
        this.projectiles = [];
        this.particles = [];
        if (this.shapeSystem) {
          this.shapeSystem.clear();
          this.shapeSystem.initialize({ x: this.player.x, y: this.player.y });
        }
      }
    }

    // ==================== MILESTONE SYSTEM ====================
    function checkMilestones(player) {
      const currentMilestone = Math.floor(player.score / CONFIG.MILESTONE_INTERVAL);
      
      if (currentMilestone > player.milestones) {
        const milestonesGained = currentMilestone - player.milestones;
        player.milestones = currentMilestone;
        
        // Apply milestone bonuses
        applyMilestoneUpgrades(player, milestonesGained);
        
        // Show milestone notification
        showMilestoneNotification(currentMilestone);
        
        console.log(`🎉 MILESTONE ${currentMilestone} REACHED!`);
        console.log(`📊 Player Growth: Vision +${(CONFIG.MILESTONE_VISION_BONUS * 100).toFixed(1)}%, Size +${(CONFIG.MILESTONE_SIZE_BONUS * 100).toFixed(1)}%, Health +${(CONFIG.MILESTONE_HEALTH_BONUS * 100).toFixed(1)}%`);
        console.log(`⚠️ Speed decreased by ${(CONFIG.MILESTONE_SPEED_PENALTY * 100).toFixed(1)}%`);
        
        return true;
      }
      
      return false;
    }

    function applyMilestoneUpgrades(player, milestonesGained) {
      for (let i = 0; i < milestonesGained; i++) {
        // Increase vision range
        player.visionRange *= (1 + CONFIG.MILESTONE_VISION_BONUS);
        
        // Increase size
        player.currentSize *= (1 + CONFIG.MILESTONE_SIZE_BONUS);
        
        // Increase health
        const oldMaxHealth = player.currentMaxHealth;
        player.currentMaxHealth *= (1 + CONFIG.MILESTONE_HEALTH_BONUS);
        const healthIncrease = player.currentMaxHealth - oldMaxHealth;
        player.health += healthIncrease; // Add the bonus health
        player.maxHealth = player.currentMaxHealth;
        
        // Decrease speed (penalty for growth)
        player.currentSpeed *= (1 - CONFIG.MILESTONE_SPEED_PENALTY);
        
        // Increase bullet size
        player.currentBulletSize *= (1 + CONFIG.MILESTONE_BULLET_BONUS);
      }
      
      // Ensure minimum values
      player.currentSpeed = Math.max(player.currentSpeed, 1);
      player.visionRange = Math.max(player.visionRange, 400);
    }

    function showMilestoneNotification(milestone) {
      const notification = document.createElement('div');
      notification.className = 'milestone-notification';
      notification.innerHTML = `🎯 MILESTONE ${milestone}!<br>🔥 PLAYER EVOLVED! 🔥`;
      document.body.appendChild(notification);
      
      setTimeout(() => {
        if (notification.parentNode) notification.remove();
      }, 3000);
    }

    function showLevelNotification(level) {
      const notification = document.createElement('div');
      notification.className = 'level-notification';
      notification.innerHTML = `⬆️ LEVEL ${level}!<br>+1 Upgrade Point!`;
      document.body.appendChild(notification);
      
      setTimeout(() => {
        if (notification.parentNode) notification.remove();
      }, 2000);
    }

    function updatePlayerStats(player) {
      const visionPercent = Math.round((player.visionRange / 800) * 100);
      const sizePercent = Math.round((player.currentSize / CONFIG.PLAYER_BASE_SIZE) * 100);
      const speedPercent = Math.round((player.currentSpeed / CONFIG.PLAYER_BASE_SPEED) * 100);
      const healthPercent = Math.round((player.currentMaxHealth / CONFIG.PLAYER_BASE_HEALTH) * 100);
      const bulletPercent = Math.round((player.currentBulletSize / CONFIG.BULLET_BASE_SIZE) * 100);
      
      safeSetText('vision-stat', `${visionPercent}%`);
      safeSetText('size-stat', `${sizePercent}%`);
      safeSetText('speed-stat', `${speedPercent}%`);
      safeSetText('health-stat', `${healthPercent}%`);
      safeSetText('bullet-stat', `${bulletPercent}%`);
      safeSetText('milestone-count', `${player.milestones}`);
      
      // Update next milestone info
      const nextMilestone = (player.milestones + 1) * CONFIG.MILESTONE_INTERVAL;
      safeSetText('milestone-info', `Next Milestone: ${nextMilestone.toLocaleString()}`);
    }

    // ==================== PROJECTILE & PARTICLE CLASSES ====================
    class Projectile {
      constructor(x, y, angle, damage, speed, size) {
        this.x = x; this.y = y;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.damage = damage;
        this.lifetime = CONFIG.BULLET_LIFETIME;
        this.size = size;
      }
      
      update(deltaTime) {
        this.x += this.vx; this.y += this.vy;
        this.lifetime -= deltaTime;
        return this.lifetime > 0 && this.x >= 0 && this.x <= CONFIG.WORLD_WIDTH && 
               this.y >= 0 && this.y <= CONFIG.WORLD_HEIGHT;
      }
    }

    class Particle {
      constructor(x, y, vx, vy, color, size, options = {}) {
        this.x = x; this.y = y; this.vx = vx; this.vy = vy;
        this.color = color; this.size = size; this.lifetime = 1;
        this.fadeRate = options.fadeRate || 0.02;
      }
      
      update(deltaTime) {
        this.x += this.vx; this.y += this.vy;
        this.vx *= 0.98; this.vy *= 0.98;
        this.lifetime -= this.fadeRate;
        this.size *= 0.98;
        return this.lifetime > 0 && this.size > 0.1;
      }
    }

    // ==================== SIMPLE SHAPE SYSTEM ====================
    class SimpleShapeSystem {
      constructor(worldWidth, worldHeight) {
        this.worldWidth = worldWidth;
        this.worldHeight = worldHeight;
        this.shapes = [];
        this.maxShapes = CONFIG.MAX_SHAPES;
        this.spawnRate = CONFIG.SHAPE_SPAWN_RATE;
        this.lastSpawnTime = Date.now();
        this.shapeIdCounter = 0;
        
        this.shapeTypes = {
          triangle: { sides: 3, size: 25, health: 30, xp: 10, color: '#FF6B6B', speed: 1.2, damage: 5 },
          square: { sides: 4, size: 30, health: 50, xp: 20, color: '#FFE66D', speed: 0.8, damage: 8 },
          pentagon: { sides: 5, size: 35, health: 80, xp: 35, color: '#4ECDC4', speed: 0.6, damage: 10 },
          hexagon: { sides: 6, size: 40, health: 120, xp: 50, color: '#A8E6CF', speed: 0.4, damage: 15 }
        };
      }
      
      initialize(playerPosition) {
        this.shapes = [];
        for (let i = 0; i < Math.min(50, this.maxShapes); i++) {
          this.spawnShape(playerPosition);
        }
      }
      
      spawnShape(playerPosition) {
        if (this.shapes.length >= this.maxShapes) return null;
        
        const types = Object.keys(this.shapeTypes);
        const type = types[Math.floor(Math.random() * types.length)];
        const config = this.shapeTypes[type];
        
        let x, y;
        let attempts = 0;
        do {
          x = Math.random() * this.worldWidth;
          y = Math.random() * this.worldHeight;
          attempts++;
        } while (
          playerPosition &&
          Math.sqrt(Math.pow(x - playerPosition.x, 2) + Math.pow(y - playerPosition.y, 2)) < 300 &&
          attempts < 50
        );
        
        const shape = {
          id: `shape_${this.shapeIdCounter++}`,
          type: type,
          x: x, y: y,
          vx: (Math.random() - 0.5) * config.speed,
          vy: (Math.random() - 0.5) * config.speed,
          size: config.size,
          sides: config.sides,
          health: config.health,
          maxHealth: config.health,
          xp: config.xp,
          color: config.color,
          damage: config.damage,
          angle: Math.random() * Math.PI * 2,
          rotationSpeed: (Math.random() - 0.5) * 0.02
        };
        
        this.shapes.push(shape);
        return shape;
      }
      
      update(deltaTime, playerPosition) {
        const now = Date.now();
        
        if (now - this.lastSpawnTime > this.spawnRate) {
          if (this.shapes.length < this.maxShapes) {
            this.spawnShape(playerPosition);
          }
          this.lastSpawnTime = now;
        }
        
        for (let i = this.shapes.length - 1; i >= 0; i--) {
          const shape = this.shapes[i];
          
          shape.x += shape.vx;
          shape.y += shape.vy;
          shape.angle += shape.rotationSpeed;
          
          // Bounce off boundaries
          if (shape.x - shape.size < 0 || shape.x + shape.size > this.worldWidth) {
            shape.vx *= -1;
            shape.x = Math.max(shape.size, Math.min(this.worldWidth - shape.size, shape.x));
          }
          if (shape.y - shape.size < 0 || shape.y + shape.size > this.worldHeight) {
            shape.vy *= -1;
            shape.y = Math.max(shape.size, Math.min(this.worldHeight - shape.size, shape.y));
          }
          
          // Random movement changes
          if (Math.random() < 0.01) {
            const config = this.shapeTypes[shape.type];
            shape.vx = (Math.random() - 0.5) * config.speed;
            shape.vy = (Math.random() - 0.5) * config.speed;
          }
          
          if (shape.health <= 0) {
            this.shapes.splice(i, 1);
          }
        }
      }
      
      getAllShapes() {
        return this.shapes;
      }
      
      clear() {
        this.shapes = [];
        this.shapeIdCounter = 0;
      }
    }

    // ==================== SIMPLE COLLISION SYSTEM ====================
    class SimpleCollisionSystem {
      constructor() {
        this.playerRadius = 25;
        this.projectileRadius = 6;
      }
      
      checkCollision(obj1, obj2) {
        const dx = obj1.x - obj2.x;
        const dy = obj1.y - obj2.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return distance < (obj1.size + obj2.size);
      }
      
      handleAllCollisions(gameState) {
        const results = [];
        const player = gameState.player;
        
        // Check projectile-shape collisions
        for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
          const projectile = gameState.projectiles[i];
          
          for (let j = gameState.shapes.length - 1; j >= 0; j--) {
            const shape = gameState.shapes[j];
            const dx = projectile.x - shape.x;
            const dy = projectile.y - shape.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < projectile.size + shape.size) {
              shape.health -= projectile.damage;
              
              // Create hit particles
              for (let k = 0; k < 5; k++) {
                gameState.particles.push(new Particle(
                  shape.x, shape.y,
                  (Math.random() - 0.5) * 5,
                  (Math.random() - 0.5) * 5,
                  shape.color,
                  Math.random() * 5 + 2
                ));
              }
              
              if (shape.health <= 0) {
                player.xp += shape.xp;
                player.score += shape.xp * 10;
                
                // Check milestones AND levels
                checkMilestones(player);
                checkLevelUp(player);
                
                // Create destruction particles
                for (let k = 0; k < 15; k++) {
                  gameState.particles.push(new Particle(
                    shape.x, shape.y,
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10,
                    shape.color,
                    Math.random() * 8 + 3
                  ));
                }
                
                gameState.shapes.splice(j, 1);
              }
              
              gameState.projectiles.splice(i, 1);
              break;
            }
          }
        }
        
        return results;
      }
    }

    // ==================== LEVEL SYSTEM ====================
    function checkLevelUp(player) {
      while (player.xp >= player.xpToNext) {
        player.xp -= player.xpToNext;
        player.level++;
        player.xpToNext = 100 * player.level;
        player.upgradePoints += 1;
        
        // Show level up notification
        showLevelNotification(player.level);
        
        console.log(`🎉 LEVEL UP! Level ${player.level}! ${player.upgradePoints} upgrade points.`);
        
        return true;
      }
      return false;
    }

    // ==================== MAIN GAME CLASS ====================
    class Game {
      constructor() {
        if (window.gameRunning) {
          console.warn('Game already running!');
          return window.game;
        }
        window.gameRunning = true;
        
        this.canvas = safeGetElement('gameCanvas');
        this.ctx = this.canvas ? this.canvas.getContext('2d') : null;
        this.minimapCanvas = safeGetElement('minimapCanvas');
        this.minimapCtx = this.minimapCanvas ? this.minimapCanvas.getContext('2d') : null;
        
        if (!this.canvas || !this.ctx) {
          console.error('❌ Cannot find game canvas!');
          window.gameRunning = false;
          return;
        }
        
        this.state = new GameState();
        this.lastTime = 0;
        this.running = true;
        this.fps = 0;
        this.frameCount = 0;
        this.lastFPSTime = Date.now();
        
        window.game = this;
        
        this.initializeSystems();
        this.setupCanvas();
        this.setupEventListeners();
        this.initializeShapes();
        this.gameLoop(0);
      }
      
      safeGetElement(id) {
        try {
          return document.getElementById(id);
        } catch (error) {
          console.warn(`Element ${id} not found:`, error);
          return null;
        }
      }
      
      initializeSystems() {
        this.state.shapeSystem = new SimpleShapeSystem(CONFIG.WORLD_WIDTH, CONFIG.WORLD_HEIGHT);
        this.state.collisionSystem = new SimpleCollisionSystem();
      }
      
      setupCanvas() {
        this.resizeCanvas();
        window.addEventListener('resize', () => this.resizeCanvas());
      }
      
      resizeCanvas() {
        if (!this.canvas) return;
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        
        if (this.minimapCanvas) {
          this.minimapCanvas.width = 176;
          this.minimapCanvas.height = 176;
        }
      }
      
      setupEventListeners() {
        window.addEventListener('keydown', (e) => {
          this.state.keys[e.code] = true;
          this.handleKeys(e.code);
        });
        
        window.addEventListener('keyup', (e) => {
          this.state.keys[e.code] = false;
        });
        
        if (this.canvas) {
          this.canvas.addEventListener('mousemove', (e) => {
            this.state.mouse.x = e.clientX;
            this.state.mouse.y = e.clientY;
          });
          
          this.canvas.addEventListener('mousedown', () => {
            this.state.mouse.pressed = true;
          });
          
          this.canvas.addEventListener('mouseup', () => {
            this.state.mouse.pressed = false;
          });
        }
        
        // Setup upgrade buttons
        this.setupUpgradeButtons();
      }
      
      setupUpgradeButtons() {
        try {
          const buttons = document.querySelectorAll('.upgrade-option');
          buttons.forEach(button => {
            button.addEventListener('click', (e) => {
              const upgrade = e.currentTarget.dataset.upgrade;
              if (upgrade) this.applyUpgrade(upgrade);
            });
          });
        } catch (error) {
          console.warn('Could not setup upgrade buttons:', error);
        }
      }
      
      handleKeys(code) {
        switch(code) {
          case 'KeyU':
            if (this.state.player.upgradePoints > 0) this.toggleUpgradeMenu();
            break;
          case 'Escape':
            if (this.state.upgradeMenuOpen) this.toggleUpgradeMenu();
            break;
        }
      }
      
      toggleUpgradeMenu() {
        try {
          const menu = document.getElementById('upgrade-menu');
          if (!menu) return;
          
          this.state.upgradeMenuOpen = !this.state.upgradeMenuOpen;
          
          if (this.state.upgradeMenuOpen && this.state.player.upgradePoints > 0) {
            menu.classList.remove('hidden');
            menu.style.display = 'block';
          } else {
            menu.classList.add('hidden');
            menu.style.display = 'none';
            this.state.upgradeMenuOpen = false;
          }
        } catch (error) {
          console.error('Error toggling upgrade menu:', error);
        }
      }
      
      applyUpgrade(type) {
        if (this.state.player.upgradePoints <= 0) return;
        
        const player = this.state.player;
        switch(type) {
          case 'health': 
            player.maxHealth += 20; 
            player.currentMaxHealth += 20;
            player.health += 20; 
            break;
          case 'damage': 
            player.stats.damage *= 1.25; 
            break;
          case 'reload': 
            player.stats.reload *= 1.2; 
            break;
          case 'speed': 
            player.stats.speed *= 1.15;
            player.currentSpeed *= 1.15;
            break;
          case 'regen': 
            player.stats.regen *= 1.5; 
            break;
          case 'bulletSpeed': 
            player.stats.bulletSpeed *= 1.2; 
            break;
        }
        
        player.upgradePoints--;
        if (player.upgradePoints <= 0) this.toggleUpgradeMenu();
      }
      
      initializeShapes() {
        if (this.state.shapeSystem) {
          this.state.shapeSystem.initialize({ x: this.state.player.x, y: this.state.player.y });
        }
      }
      
      // ==================== UPDATE LOGIC ====================
      update(deltaTime) {
        this.updatePlayer(deltaTime);
        
        // Update projectiles
        this.state.projectiles = this.state.projectiles.filter(p => p.update(deltaTime));
        
        // Update shapes
        if (this.state.shapeSystem) {
          this.state.shapeSystem.update(deltaTime, { x: this.state.player.x, y: this.state.player.y });
          this.state.shapes = this.state.shapeSystem.getAllShapes();
        }
        
        // Update particles
        this.state.particles = this.state.particles.filter(p => p.update(deltaTime));
        
        this.checkCollisions();
        this.updatePlayerRegen();
        this.updateCamera();
        this.updateUI();
        this.updateFPS();
        this.updateMinimap();
      }
      
      updatePlayer(deltaTime) {
        const player = this.state.player;
        const keys = this.state.keys;
        
        // Movement input
        let dx = 0, dy = 0;
        if (keys['KeyW'] || keys['ArrowUp']) dy = -1;
        if (keys['KeyS'] || keys['ArrowDown']) dy = 1;
        if (keys['KeyA'] || keys['ArrowLeft']) dx = -1;
        if (keys['KeyD'] || keys['ArrowRight']) dx = 1;
        
        // Normalize diagonal movement
        if (dx !== 0 && dy !== 0) {
          dx *= 0.707; dy *= 0.707;
        }
        
        // Apply movement with current speed (affected by milestones AND upgrades)
        const totalSpeed = player.currentSpeed * player.stats.speed;
        player.vx = dx * totalSpeed;
        player.vy = dy * totalSpeed;
        player.x += player.vx;
        player.y += player.vy;
        
        // Keep player in bounds
        player.x = Math.max(player.currentSize, Math.min(CONFIG.WORLD_WIDTH - player.currentSize, player.x));
        player.y = Math.max(player.currentSize, Math.min(CONFIG.WORLD_HEIGHT - player.currentSize, player.y));
        
        // Calculate angle to mouse
        const mouseWorldX = this.state.mouse.x + this.state.camera.x;
        const mouseWorldY = this.state.mouse.y + this.state.camera.y;
        player.angle = Math.atan2(mouseWorldY - player.y, mouseWorldX - player.x);
        
        // Shooting
        if (this.state.mouse.pressed) {
          const fireRate = CONFIG.FIRE_RATE / player.stats.reload;
          if (Date.now() - this.state.lastShot > fireRate) {
            this.shoot();
            this.state.lastShot = Date.now();
          }
        }
      }
      
      shoot() {
        const player = this.state.player;
        const bulletSpeed = CONFIG.BULLET_BASE_SPEED * player.stats.bulletSpeed;
        const damage = CONFIG.BULLET_DAMAGE * player.stats.damage;
        const barrelLength = player.currentSize + 10;
        const bulletX = player.x + Math.cos(player.angle) * barrelLength;
        const bulletY = player.y + Math.sin(player.angle) * barrelLength;
        
        this.state.projectiles.push(new Projectile(
          bulletX, bulletY, player.angle, damage, bulletSpeed, player.currentBulletSize
        ));
        
        // Recoil
        player.vx -= Math.cos(player.angle) * 2;
        player.vy -= Math.sin(player.angle) * 2;
      }
      
      checkCollisions() {
        try {
          if (this.state.collisionSystem && this.state.collisionSystem.handleAllCollisions) {
            this.state.collisionSystem.handleAllCollisions(this.state);
          }
        } catch (error) {
          console.error('Error in collision detection:', error);
        }
      }
      
      updatePlayerRegen() {
        const player = this.state.player;
        if (player.health < player.maxHealth) {
          const regenRate = CONFIG.PLAYER_REGEN_RATE * player.stats.regen;
          player.health += regenRate;
          player.health = Math.min(player.health, player.maxHealth);
        }
      }
      
      updateCamera() {
        const player = this.state.player;
        // Adjust camera based on vision range (milestone bonus)
        this.state.camera.x = player.x - (this.canvas?.width || 800) / 2;
        this.state.camera.y = player.y - (this.canvas?.height || 600) / 2;
      }
      
      updateUI() {
        const player = this.state.player;
        
        safeSetText('score', `Score: ${player.score.toLocaleString()}`);
        safeSetText('level', `Level: ${player.level}`);
        
        // Update health bar
        this.updateBar('health', player.health, player.maxHealth);
        
        // Update XP bar
        this.updateBar('xp', player.xp, player.xpToNext);
        
        // Update player stats
        updatePlayerStats(player);
      }
      
      updateBar(type, current, max) {
        try {
          const fill = document.getElementById(`${type}-fill`);
          const text = document.getElementById(`${type}-text`);
          
          if (fill && text) {
            const percent = (current / max) * 100;
            fill.style.width = `${percent}%`;
            text.textContent = `${Math.floor(current)}/${max}`;
          }
        } catch (error) {
          console.warn(`Error updating ${type} bar:`, error);
        }
      }
      
      updateFPS() {
        this.frameCount++;
        const now = Date.now();
        
        if (now - this.lastFPSTime >= 1000) {
          this.fps = this.frameCount;
          this.frameCount = 0;
          this.lastFPSTime = now;
          safeSetText('fps', `FPS: ${this.fps}`);
        }
      }
      
      updateMinimap() {
        if (!this.minimapCtx) return;
        
        try {
          const minimapSize = 176;
          const scaleX = minimapSize / CONFIG.WORLD_WIDTH;
          const scaleY = minimapSize / CONFIG.WORLD_HEIGHT;
          
          // Clear minimap
          this.minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
          this.minimapCtx.fillRect(0, 0, minimapSize, minimapSize);
          
          // Draw shapes as dots
          this.minimapCtx.fillStyle = 'rgba(255, 255, 0, 0.6)';
          this.state.shapes.forEach(shape => {
            const x = shape.x * scaleX;
            const y = shape.y * scaleY;
            this.minimapCtx.beginPath();
            this.minimapCtx.arc(x, y, 1, 0, Math.PI * 2);
            this.minimapCtx.fill();
          });
          
          // Draw player
          const playerX = this.state.player.x * scaleX;
          const playerY = this.state.player.y * scaleY;
          
          this.minimapCtx.fillStyle = '#00B2E1';
          this.minimapCtx.beginPath();
          this.minimapCtx.arc(playerX, playerY, 3, 0, Math.PI * 2);
          this.minimapCtx.fill();
          
          // Draw border
          this.minimapCtx.strokeStyle = 'rgba(0, 178, 225, 0.5)';
          this.minimapCtx.lineWidth = 2;
          this.minimapCtx.strokeRect(0, 0, minimapSize, minimapSize);
        } catch (error) {
          console.error('Error drawing minimap:', error);
        }
      }
      
      // ==================== RENDERING ====================
      render() {
        if (!this.ctx) return;
        
        try {
          // Clear canvas
          this.ctx.fillStyle = '#1a1a2e';
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
          
          this.ctx.save();
          this.ctx.translate(-this.state.camera.x, -this.state.camera.y);
          
          this.drawGrid();
          this.drawShapes();
          this.drawProjectiles();
          this.drawParticles();
          this.drawPlayer();
          
          this.ctx.restore();
        } catch (error) {
          console.error('Error in render:', error);
        }
      }
      
      drawGrid() {
        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
        this.ctx.lineWidth = 1;
        
        const startX = Math.floor(this.state.camera.x / CONFIG.GRID_SIZE) * CONFIG.GRID_SIZE;
        const startY = Math.floor(this.state.camera.y / CONFIG.GRID_SIZE) * CONFIG.GRID_SIZE;
        const endX = startX + this.canvas.width + CONFIG.GRID_SIZE;
        const endY = startY + this.canvas.height + CONFIG.GRID_SIZE;
        
        // Draw vertical lines
        for (let x = startX; x <= endX; x += CONFIG.GRID_SIZE) {
          if (x >= 0 && x <= CONFIG.WORLD_WIDTH) {
            this.ctx.beginPath();
            this.ctx.moveTo(x, Math.max(0, startY));
            this.ctx.lineTo(x, Math.min(CONFIG.WORLD_HEIGHT, endY));
            this.ctx.stroke();
          }
        }
        
        // Draw horizontal lines
        for (let y = startY; y <= endY; y += CONFIG.GRID_SIZE) {
          if (y >= 0 && y <= CONFIG.WORLD_HEIGHT) {
            this.ctx.beginPath();
            this.ctx.moveTo(Math.max(0, startX), y);
            this.ctx.lineTo(Math.min(CONFIG.WORLD_WIDTH, endX), y);
            this.ctx.stroke();
          }
        }
      }
      
      drawPlayer() {
        const player = this.state.player;
        
        this.ctx.save();
        this.ctx.translate(player.x, player.y);
        this.ctx.rotate(player.angle);
        
        // Tank body (size affected by milestones)
        this.ctx.fillStyle = '#00B2E1';
        this.ctx.strokeStyle = '#0099CC';
        this.ctx.lineWidth = 3;
        this.ctx.beginPath();
        this.ctx.arc(0, 0, player.currentSize, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.stroke();
        
        // Tank barrel (size matches player growth)
        this.ctx.fillStyle = '#808080';
        this.ctx.strokeStyle = '#606060';
        this.ctx.lineWidth = 2;
        const barrelLength = player.currentSize + 15;
        const barrelWidth = player.currentSize * 0.5;
        this.ctx.fillRect(0, -barrelWidth/2, barrelLength, barrelWidth);
        this.ctx.strokeRect(0, -barrelWidth/2, barrelLength, barrelWidth);
        
        this.ctx.restore();
        
        // Health bar (if damaged)
        if (player.health < player.maxHealth) {
          this.drawHealthBar(player.x, player.y - player.currentSize - 15, player.health, player.maxHealth);
        }
      }
      
      drawHealthBar(x, y, health, maxHealth) {
        const barWidth = 50, barHeight = 6;
        const healthPercent = health / maxHealth;
        
        // Background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        this.ctx.fillRect(x - barWidth/2, y, barWidth, barHeight);
        
        // Health fill
        this.ctx.fillStyle = healthPercent > 0.5 ? '#4CAF50' : healthPercent > 0.25 ? '#FFC107' : '#F44336';
        this.ctx.fillRect(x - barWidth/2, y, barWidth * healthPercent, barHeight);
      }
      
      drawShapes() {
        this.state.shapes.forEach(shape => {
          this.ctx.save();
          this.ctx.translate(shape.x, shape.y);
          this.ctx.rotate(shape.angle || 0);
          
          // Create gradient for shape
          const gradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, shape.size);
          gradient.addColorStop(0, this.lightenColor(shape.color, 30));
          gradient.addColorStop(1, shape.color);
          
          this.ctx.fillStyle = gradient;
          this.ctx.strokeStyle = this.darkenColor(shape.color, 30);
          this.ctx.lineWidth = 3;
          
          // Draw shape based on sides
          this.ctx.beginPath();
          if (shape.sides === 4) {
            this.ctx.rect(-shape.size, -shape.size, shape.size * 2, shape.size * 2);
          } else {
            this.drawPolygon(shape.sides, shape.size);
          }
          this.ctx.fill();
          this.ctx.stroke();
          
          this.ctx.restore();
        });
      }
      
      drawPolygon(sides, size) {
        const angle = (Math.PI * 2) / sides;
        
        for (let i = 0; i < sides; i++) {
          const x = Math.cos(angle * i - Math.PI / 2) * size;
          const y = Math.sin(angle * i - Math.PI / 2) * size;
          
          if (i === 0) {
            this.ctx.moveTo(x, y);
          } else {
            this.ctx.lineTo(x, y);
          }
        }
        
        this.ctx.closePath();
      }
      
      drawProjectiles() {
        this.state.projectiles.forEach(projectile => {
          this.ctx.save();
          
          // Draw projectile with size affected by milestones
          this.ctx.fillStyle = '#FFE600';
          this.ctx.shadowBlur = 10;
          this.ctx.shadowColor = '#FFE600';
          this.ctx.beginPath();
          this.ctx.arc(projectile.x, projectile.y, projectile.size, 0, Math.PI * 2);
          this.ctx.fill();
          this.ctx.shadowBlur = 0;
          
          this.ctx.restore();
        });
      }
      
      drawParticles() {
        this.state.particles.forEach(particle => {
          this.ctx.save();
          this.ctx.globalAlpha = particle.lifetime;
          
          this.ctx.fillStyle = particle.color;
          this.ctx.beginPath();
          this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
          this.ctx.fill();
          
          this.ctx.restore();
        });
      }
      
      // ==================== UTILITY FUNCTIONS ====================
      
      lightenColor(hex, percent) {
        try {
          const num = parseInt(hex.replace('#', ''), 16);
          const amt = Math.round(2.55 * percent);
          const R = (num >> 16) + amt;
          const G = (num >> 8 & 0x00FF) + amt;
          const B = (num & 0x0000FF) + amt;
          
          return '#' + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
            (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
            (B < 255 ? B < 1 ? 0 : B : 255))
            .toString(16).slice(1);
        } catch (error) {
          return hex;
        }
      }
      
      darkenColor(hex, percent) {
        try {
          const num = parseInt(hex.replace('#', ''), 16);
          const amt = Math.round(2.55 * percent);
          const R = (num >> 16) - amt;
          const G = (num >> 8 & 0x00FF) - amt;
          const B = (num & 0x0000FF) - amt;
          
          return '#' + (0x1000000 + (R > 0 ? R : 0) * 0x10000 +
            (G > 0 ? G : 0) * 0x100 +
            (B > 0 ? B : 0))
            .toString(16).slice(1);
        } catch (error) {
          return hex;
        }
      }
      
      // ==================== GAME LOOP ====================
      gameLoop(currentTime) {
        if (!this.running) return;
        
        try {
          const deltaTime = currentTime - this.lastTime;
          this.lastTime = currentTime;
          
          // Cap delta time to prevent large jumps
          const cappedDelta = Math.min(deltaTime, 50);
          
          this.update(cappedDelta);
          this.render();
          
          requestAnimationFrame((time) => this.gameLoop(time));
        } catch (error) {
          console.error('Error in game loop:', error);
          // Try to recover by continuing the loop
          requestAnimationFrame((time) => this.gameLoop(time));
        }
      }
    }

    // ==================== UTILITY FUNCTIONS ====================
    function safeGetElement(id) {
      try {
        return document.getElementById(id);
      } catch (error) {
        console.warn(`Element ${id} not found:`, error);
        return null;
      }
    }

    function safeSetText(id, text) {
      try {
        const element = document.getElementById(id);
        if (element) element.textContent = text;
      } catch (error) {
        console.warn(`Cannot set text for ${id}:`, error);
      }
    }

    // ==================== INITIALIZATION ====================
    
    // Prevent multiple instances
    if (typeof window !== 'undefined') {
      // Wait for DOM to be ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
          new Game();
        });
      } else {
        // DOM is already ready
        new Game();
      }
      
      console.log('🎮 Complete Milestone + Level Game loaded!');
      console.log('🎯 Features:');
      console.log('  ✅ Milestone system every 1000 points');
      console.log('  ✅ Level system with upgrade points');
      console.log('  ✅ Working minimap');
      console.log('  ✅ Upgrades menu (Press U)');
      console.log('  ✅ Player grows with milestones');
      console.log('  ✅ Speed penalty balanced with power');
      console.log('  ✅ No lag from notifications');
    }
  </script>
</body>
</html>